#!/bin/bash
#
# Awesome Powers - scripts & config files of pure awesomeness
#
# Copyright 2018-2021 Michael D Labriola <veggiemike@sourceruckus.org>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# Intended to be called periodically, checks that the system's default gateway
# is reachable.  If it is NOT reachable, a secondary gateway is used as a
# backup.  If it IS reachable, secondary gateway is removed.
#
# NOTE: All output appended to logfile, which is then mailed and removed each
#       night (log rotation and mailing is not this script's responsibility).
#
# FIXME: Add --mailto support, so I can get email whenever check-gateway
#        changes anything.  Would be best if this was set in the config file
#        and also settable via command line so that a default email address (or
#        addresses) can get email whenever anyone invokes check-gateway and it
#        actually changes things (i.e., not --dry-run and usable gateways have
#        changed).
#
# FIXME: Add outside-the-gateway checking.  In other words, make sure we can
#        ping a host OUTSIDE the gateway before we assume it's a usable
#        gateway.  Currently, we only ping the gateway itself.  Could try
#        Google Public DNS servers 8.8.8.8 and 8.8.4.4 and the Cloudflare DNS
#        servers 1.1.1.1 and 1.0.0.1 and treat the gateway as usuable if we get
#        ANY responses.
#
# FIXME: Raise interface during testing... nmcli con up
#

# parse our config
[ -f $0.conf ] && . $0.conf

log=$0.log
lock=$0.lock


usage()
{
    echo "usage: $(basename $0) [--help] [--verbose] [--dry-run] [--stdout]"
    echo
    echo "By default, output is appended to $log and is silent unless"
    echo "something changes."
}


opt_dryrun=
opt_verbose=
opt_stdout=
while [ $# -gt 0 ] ; do
    case $1 in
        --help)
            usage
            exit 0
            ;;
        -v|--verbose)
            opt_verbose=1
            ;;
        -n|--dry-run)
            opt_dryrun=1
            ;;
        --stdout)
            opt_stdout=1
            ;;
        *)
            echo "Unknown option or parameter \"$1\""
            echo
            usage
            exit 1
            ;;
    esac

    shift
done



# debug echo - only prints if enabled
decho()
{
    if [ -n "$opt_verbose" ]; then
        echo "$*"
    fi
}


# dry-run eval - evals unless dry-run specified
deval()
{
    if [ -z "$opt_dryrun" ]; then
        eval $*
    fi
}


iface_get_routes()
{
    # try manual gateway
    gw=$(nmcli con show $1 |awk '/^IP4.GATEWAY/ {print $NF}')
    if [ "$gw" = "" -o "$gw" = "--" ]; then
        # try DHCP otpions
        gw=$(nmcli con show $1 |awk '/^DHCP4.OPTION[[:print:]]* routers =/ {print $NF}')
    fi

    # if we got a gateway, we need to format it as a route by adding 0.0.0.0/0
    # in front
    if [ -n "$gw" ]; then
        gw="0.0.0.0/0 $gw"
    fi
    gw=($gw)

    # now check for additional routes, first manually configured ones, then
    # dhcp
    #
    # FIXME: definately room for improvement in the parsing here...  we're
    #        assuming the field numbers of the IPs we want are $4 and $7.
    #        we're also assuming that the first pair is 'network' '0.0.0.0/0',
    #        which we don't want to add.
    #
    # FIXME: shoot, the IP4.ROUTE stuff is only for the active
    #        configuration... in other words, if the interface is fully
    #        activated, but we've manually removed the route, this gets
    #        nothing...  we should be looking at ipv4.gateway and ipv4.routes
    #        instead, i guess
    #
    routes=($(nmcli con show $1 |awk '/^IP4.ROUTE\[[^1]/ {print $4 $7}' | tr ',' ' '))
    # FIXME: actually, i haven't run into a situation yet where DHCP is
    #        providing additional static routes.  It can as dhcp option 121,
    #        but i'd have to configure a DHCP server to do that to test
    #        parsing.... should show up as 'classless-static-route', but i'm
    #        not sure how nmcli displays it (e.g., single line w/ commas,
    #        single line w/ spaces, multiple lines?)

    # don't duplicte default gw if it shows up both as gw and a static route
    #
    # NOTE: We're assuming that if the gw is listed as a static route, it's the
    #       frist one.
    #
    
    if [ "${gw[0]}" != "${routes[0]}" ] && [ "${gw[1]}" != "${routes[1]}" ]; then
        echo ${gw[@]} ${routes[@]}
    else
        echo ${routes[@]}
    fi
}


iface_get_state()
{
    state=$(nmcli con show $1 |awk '/^GENERAL.STATE/ {print $NF}')
    echo $state
}


iface_get_devname()
{
    # FIXME: I originally was using GENERAL.IP-IFACE here, which sounds more
    #        likely to always be correct than GENERAL.DEVICES... but it looks
    #        like Ubuntu 18.04's version of NetworkManager doesn't expose
    #        IP-IFACE.  Eventually switch over, or maybe use IP-IFACE if
    #        non-empty otherwise DEVICES?
    #
    nmcli con show $1 |awk '/^GENERAL.DEVICES/ {print $NF}'
}


ip_is_reachable()
{
    ping -w1 -c1 $1 >/dev/null 2>&1
}


timestamp()
{
    date -Iseconds
}


iface_remove_routes()
{
    local iface
    local dev
    local v
    local routes
    local r
    local i
    local go

    iface=$1

    # get the device name
    dev=$(iface_get_devname $iface)
    decho "looking up routes provided by $iface ($dev)"
    
    # figure out routes, first from manual config, then from nm info
    v=${iface}_routes
    routes=$(echo ${!v} | tr ',' ' ')
    [ -z "$routes" ] && routes=$(iface_get_routes $iface)
    if [ -z "$routes" ]; then
        return
    fi

    decho $routes
    r=($(echo $routes | tr ',' '\n'))
    for ((i=0; i<${#r[@]}; i+=2)); do
        #decho ip route show ${r[i]} via ${r[i+1]} dev $dev
        if [ -n "$(ip route show ${r[i]} via ${r[i+1]} dev $dev)" ]; then
            go="ip route del ${r[i]} via ${r[i+1]} dev $dev"
            echo $(timestamp): $go
            deval $go
        fi
    done
}


remove_all_managed_routes()
{
    # make sure this only removes things a single time
    [ -n "$NO_MORE_REMOVING" ] && return
    local iface
    local dev
    local v
    local routes
    local r
    local i
    local go
    for iface in $*; do
        iface_remove_routes $iface
        
        # check for dependent ifaces
        v=${iface}_deps
        deps=${!v}
        if [ -n "$deps" ]; then
            decho "$iface deps: $deps"
            remove_all_managed_routes $deps
        fi

    done
    export NO_MORE_REMOVING=y
}


check_ifaces()
{
    for iface in $*; do
        decho checking iface: $iface
        
        # check iface state, skip if down
        #
        # FIXME: good idea originally, but if our connection goes down (e.g.,
        #        the 4gmodem I ues does this when "carrier-changed" happens,
        #        and it's kinda frequent), we need to re-raise it.
        #
        #        this means, any interface listed WILL get raised, so make sure
        #        to remove dead interfaces that shouldn't be auto-raised.
        #
        if [ "$(iface_get_state $iface)" != "activated" ]; then
            decho "skipping inactive interface"
            continue
        fi

        # get the device name
        dev=$(iface_get_devname $iface)
        decho dev: $dev
        
        # figure out routes, first from manual config, then from nm info
        v=${iface}_routes
        routes=$(echo ${!v} | tr ',' ' ')
        [ -z "$routes" ] && routes=$(iface_get_routes $iface)
        if [ -z "$routes" ]; then
            echo "WARNING: no routes for $iface"
            continue
        else
            decho "routes: $routes"
        fi
        
        # FIXME: What to do if there's more than one route... they should be listed
        #        in pairs of `target` `gateway`... should we only add the routes if
        #        they're ALL available?
        #
        #        In reality, all the use cases I've run into involve a single ip
        #        being added as a route to multiple subnets... so we could just
        #        check the first one.  If we do check subsequent ones, we should
        #        doulbe check that it's actually a different IP so we don't waste
        #        time pinging the same IP over and over.
        #
        #        Fow now, just take the 1st ip, which should be the 2nd item in
        #        routes
        #
        r=($(echo $routes | tr ',' '\n'))
        decho checking ${r[1]}

        if ip_is_reachable ${r[1]}; then
            # check if the route is already there
            #
            # NOTE: it doesn't hurt to add it a second time, but we want the
            #       output of this script to be silent if nothing needed to be
            #       changed.
            #
            decho "interface $iface is up, processing routes"
            for ((i=0; i<${#r[@]}; i+=2)); do
                #echo ip route show ${r[i]} via ${r[i+1]} dev $dev
                #blarg=$(ip route show ${r[i]} via ${r[i+1]} dev $dev)
                #echo blarg: $blarg
                if [ -z "$(ip route show ${r[i]} via ${r[i+1]} dev $dev)" ]; then
                    # we're really modifying the routing table, clear out all
                    # managed routes first
                    remove_all_managed_routes $*
                    go="ip route add ${r[i]} via ${r[i+1]} dev $dev"
                    echo $(timestamp): $go
                    deval $go
                fi
            done

            # check for dependent ifaces
            v=${iface}_deps
            deps=${!v}
            if [ -n "$deps" ]; then
                decho "$iface deps: $deps"
                check_ifaces $deps
            fi

            break
        else
            decho "interface $iface not reachable"
        fi
    done
}







# redirect all output to the logfile
if [ -z "$opt_stdout" ]; then
    exec 1>>$log
    exec 2>&1
fi

go="touch $lock"
decho $go
deval $go

check_ifaces $iface_list

go="rm -f $lock"
decho $go
deval $go

exit 0
