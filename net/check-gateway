#!/bin/bash
#
# Awesome Powers - scripts & config files of pure awesomeness
#
# Copyright 2018-2021 Michael D Labriola <michael.d.labriola@gmail.com>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# Intended to be called periodically, checks that the system's default gateway
# is reachable.  If it is NOT reachable, a secondary gateway is used as a
# backup.  If it IS reachable, secondary gateway is removed.
#
# NOTE: All output appended to logfile, which is then mailed and removed each
#       night (log rotation and mailing is not this script's responsibility).
#

# parse our config
[ -f $0.conf ] && . $0.conf


log=$0.log
lock=$0.lock
stamp=$(date +"%Y-%m-%dT%H-%M-%S")

# redirect all output to the logfile
exec 1>>$log
exec 2>&1


iface_get_routes()
{
    # try manual gateway
    gw=$(nmcli con show $1 |awk '/^IP4.GATEWAY/ {print $NF}')
    if [ "$gw" = "" -o "$gw" = "--" ]; then
        # try DHCP otpions
        gw=$(nmcli con show $1 |awk '/^DHCP4.OPTION[[:print:]]* routers =/ {print $NF}')
    fi

    # if we got a gateway, we need to format it as a route by adding 0.0.0.0/0
    # in front
    if [ -n "$gw" ]; then
        gw="0.0.0.0/0 $gw"
    fi
    gw=($gw)

    # now check for additional routes, first manually configured ones, then
    # dhcp
    #
    # FIXME: definately room for improvement in the parsing here...  we're
    #        assuming the field numbers of the IPs we want are $4 and $7.
    #        we're also assuming that the first pair is 'network' '0.0.0.0/0',
    #        which we don't want to add.
    #
    # FIXME: shoot, the IP4.ROUTE stuff is only for the active
    #        configuration... in other words, if the interface is fully
    #        activated, but we've manually removed the route, this gets
    #        nothing...  we should be looking at ipv4.gateway and ipv4.routes
    #        instead, i guess
    #
    routes=($(nmcli con show $1 |awk '/^IP4.ROUTE\[[^1]/ {print $4 $7}' | tr ',' ' '))
    # FIXME: actually, i haven't run into a situation yet where DHCP is
    #        providing additional static routes.  It can as dhcp option 121,
    #        but i'd have to configure a DHCP server to do that to test
    #        parsing.... should show up as 'classless-static-route', but i'm
    #        not sure how nmcli displays it (e.g., single line w/ commas,
    #        single line w/ spaces, multiple lines?)

    # don't duplicte default gw if it shows up both as gw and a static route
    #
    # NOTE: We're assuming that if the gw is listed as a static route, it's the
    #       frist one.
    #
    
    if [ "${gw[0]}" != "${routes[0]}" ] && [ "${gw[1]}" != "${routes[1]}" ]; then
        echo ${gw[@]} ${routes[@]}
    else
        echo ${routes[@]}
    fi
}


iface_get_state()
{
    state=$(nmcli con show $1 |awk '/^GENERAL.STATE/ {print $NF}')
    echo $state
}


iface_get_devname()
{
    nmcli con show $1 |awk '/^GENERAL.IP-IFACE/ {print $NF}'
}


ip_is_reachable()
{
    ping -w1 $1 >/dev/null 2>&1
}


timestamp()
{
    date -Iseconds
}


iface_remove_routes()
{
    local iface
    local dev
    local v
    local routes
    local r
    local i
    local go

    iface=$1

    # get the device name
    dev=$(iface_get_devname $iface)
    #echo removing routes provided by $dev
    
    # figure out routes, first from manual config, then from nm info
    v=${iface}_routes
    routes=$(echo ${!v} | tr ',' ' ')
    [ -z "$routes" ] && routes=$(iface_get_routes $iface)
    if [ -z "$routes" ]; then
        return
    fi

    #echo $routes
    r=($(echo $routes | tr ',' '\n'))
    for ((i=0; i<${#r[@]}; i+=2)); do
        #echo ip route show ${r[i]} via ${r[i+1]} dev $dev
        if [ -n "$(ip route show ${r[i]} via ${r[i+1]} dev $dev)" ]; then
            go="ip route del ${r[i]} via ${r[i+1]} dev $dev"
            #echo $(timestamp): $go
            eval $go
        fi
    done
}


remove_all_managed_routes()
{
    # make sure this only removes things a single time
    [ -n "$NO_MORE_REMOVING" ] && return
    local iface
    local dev
    local v
    local routes
    local r
    local i
    local go
    for iface in $*; do
        iface_remove_routes $iface
        
        # check for dependent ifaces
        v=${iface}_deps
        deps=${!v}
        if [ -n "$deps" ]; then
            #echo "deps: $deps"
            remove_all_managed_routes $deps
        fi

    done
    export NO_MORE_REMOVING=y
}


check_ifaces()
{
    for iface in $*; do
        #echo iface: $iface
        
        # check iface state, skip if down
        if [ "$(iface_get_state $iface)" != "activated" ]; then
            #echo "skipping inactive interface"
            continue
        fi

        # get the device name
        dev=$(iface_get_devname $iface)
        #echo dev: $dev
        
        # figure out routes, first from manual config, then from nm info
        v=${iface}_routes
        routes=$(echo ${!v} | tr ',' ' ')
        [ -z "$routes" ] && routes=$(iface_get_routes $iface)
        if [ -z "$routes" ]; then
            echo "WARNING: no routes for $iface"
            continue
        #else
        #    echo "routes: $routes"
        fi
        
        # FIXME: What to do if there's more than one route... they should be listed
        #        in pairs of `target` `gateway`... should we only add the routes if
        #        they're ALL available?
        #
        #        In reality, all the use cases I've run into involve a single ip
        #        being added as a route to multiple subnets... so we could just
        #        check the first one.  If we do check subsequent ones, we should
        #        doulbe check that it's actually a different IP so we don't waste
        #        time pinging the same IP over and over.
        #
        #        Fow now, just take the 1st ip, which should be the 2nd item in
        #        routes
        #
        r=($(echo $routes | tr ',' '\n'))
        #echo checking ${r[1]}

        if ip_is_reachable ${r[1]}; then
            # check if the route is already there
            #
            # NOTE: it doesn't hurt to add it a second time, but we want the
            #       output of this script to be silent if nothing needed to be
            #       changed.
            #
            #echo "interface $iface is up, adding it's routes"
            for ((i=0; i<${#r[@]}; i+=2)); do
                #echo ip route show ${r[i]} via ${r[i+1]} dev $dev
                #blarg=$(ip route show ${r[i]} via ${r[i+1]} dev $dev)
                #echo blarg: $blarg
                if [ -z "$(ip route show ${r[i]} via ${r[i+1]} dev $dev)" ]; then
                    # we're really modifying the routing table, clear out all
                    # managed routes first
                    remove_all_managed_routes $*
                    go="ip route add ${r[i]} via ${r[i+1]} dev $dev"
                    echo $(timestamp): $go
                    eval $go
                fi
            done

            # check for dependent ifaces
            v=${iface}_deps
            deps=${!v}
            if [ -n "$deps" ]; then
                #echo "deps: $deps"
                check_ifaces $deps
            fi

            break
        fi
    done
}


touch $lock
check_ifaces $iface_list
rm -f $lock
exit 0
