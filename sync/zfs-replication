#!/bin/bash
#
# script for doing remote zfs replication
#
# NOTE: All output appended to logfile, which is then mailed and removed each
#       night (log rotation and mailing is not this script's responsibility).
#

# parse our config
#
# FIXME: or /scrap/awesome-powers/config/sync/zfs-replication.conf?  or simply
#        $(dirname $0)/zfs-replication.conf?  or $0.conf?
#
. $0.conf


log=$0.log
lock=$0.lock
stamp=$(date +"%Y-%m-%dT%H-%M-%S")

# FIXME: we can do better than this...
if [ "$1" = "--dry-run" ] || [ "$1" = "-n" ]; then
    dryrun="-n"
else
    dryrun=
    # when not dryrun, we redirect all output to the logfile
    exec 1>>$log
    exec 2>&1
fi

# make sure we're not already running
#
# NOTE: Under normal operation, we want to simply exit if previous run is still
#       processing.  However, the end-of-day reporting modes should wait until
#       previous invocation exits.
#
# FIXME: add a timeout?
#
if [ -n "$MODE" ]; then
    while [ -f $lock ]; do
        sleep 1
    done
else
    [ -e $lock ] && exit 0
fi

# parse common status
. $(dirname $0)/../status/status-common


pick_remote()
{
    # pick remote source from $servers
    server=
    best_score=99
    for x in $servers; do
        # FIXME: not really sure how to pick one...  follow srv-router2?  check for
        #        no guests?  for now, only merry is using zfs, so we just pick him.
        #
        #        how about, reachable host w/ fewest domUs.  Or first reachable
        #        w/ zero domUs.
        #
        #        ssh $x xl list | wc -l
        #
        #if [ "$x" = "merry" ]; then
        #    server=$x
        #    break
        #fi
        reachable=$(ssh $x hostname)
        if [ -z "$reachable" ]; then
            echo $x not reachable
            continue
        fi
        has_ds=$(ssh $x zfs list -Hp $remote_ds 2>/dev/null)
        if [ -z "$has_ds" ]; then
            echo $x missing ds $remote_ds
            continue
        fi
        score=$(ssh $x xl list | wc -l)
        if [ -z "$score" ]; then
            echo failed to get score for $x
            continue
        elif [ $score -eq 2 ]; then
            echo perfect score for $x
            server=$x
            return
        elif [ $score -lt $best_score ]; then
            server=$x
            best_score=$score
        fi
    done
}


do_syncoid()
{
    if [ "$recursive" = "true" -o "$recursive" = "1" -o "$recursive" = "yes" ]; then
        recursive="-r"
    else
        recursive=
    fi

    # FIXME: use our cloned copy of syncoid w/ new --delete-target-snapshots
    #        flag until this is merged and released upstream.
    #
    go="/scrap/sanoid/syncoid --delete-target-snapshots $recursive"

    # FIXME: for some reason, things started failing all the time unless i
    #        disable resume here...  i did just recently upgrade one of the
    #        servers to OpenZFS 2.0, so maybe it got mad then...  and I'm not
    #        sure how to fix it.
    #
    go+=" --no-resume"

    for x in $exclude; do
        go+=" --exclude=$x"
    done
    #echo "$(dirname $local_ds) needs to exist, but not $local_ds"
    go+=" $remote_user@$server:$remote_ds $local_ds"
    echo $go
    if [ -z "$dryrun" ]; then
        eval $go || echo "ERROR: bad things happened!"
    fi
}



echo "--- START: $stamp ----------------------------------------------------"

touch $lock

# check for special modes
case "$MODE" in
    analyze)
        echo "Doing end of day analysis"
        failures=0
        check ERROR
        check WARN
        if [ $failures -ne 0 ]; then
            echo "!!!!"
            echo "!!!! Checks Failed: $failures"
            echo "!!!!"
        else
            echo "All checks passed.  :-)"
        fi
        ;;
    *)
        pick_remote
        if [ -z "$server" ]; then
            echo "ERROR: no suitable server found"
        else
            echo "selected server $server for replication"
            do_syncoid
        fi
esac

echo "--- END: $stamp (at $(date +"%Y-%m-%dT%H-%M-%S")) -----------------------------"
rm -f $lock
exit 0
